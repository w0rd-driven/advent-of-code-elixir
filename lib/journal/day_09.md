# Journal Entry, December 9th 2020 (Wednesday)

## Part 1

Looks like I have the bright idea of starting this **before** I start the puzzle as things could easily change. This is the first time I've changed the boilerplate to pass in the input with the `preamble_length` so we can specify 5 (during tests) or default to 25 when not present (normal day tasks). Elixir has a split method that we use as `{ preamble, message } = input |> Enum.split(preamble_length)` to split the total input into the preamble (1st 25 values) and the message (tail). From here we loop through the message list once but loop through the preamble twice, gathering values by separate index. We have to make sure both values are unique or we continue the loop until we finish. If nothing in the preamble sums to that number, add it to the list. We should stop after the first is found but there may be a benefit to building a complete list and returning the first result.

Turns out this is wrong and we need a sort of "sliding window". Having the initial preamble and setting the input is still valid but we need to split our list **every iteration** because it's the 5/25 previous numbers, not just the **first 5/25** as I had originally thought. There's a recursive function in here I'm sure but my brain is mush and has been since I started this yesterday (it's now Thursday).

Looks like I'm taking a very big hint from [here](https://github.com/LostKobrakai/aoc2020/blob/master/lib/aoc2020/day9.ex#L6) and it's so concise I can't really change much. I did more or less get to this point but this takes a much more clever approach using `Stream.chunk_every` to build our "sliding window". During the first iteration the list is the `[...preamble, total]` to borrow JS syntax. Here we pop the last value as our total and evaluate the preamble. We build a list of unique `combinations` then check the validity and return the value from `Enum.find_value` as this returns the first response we're looking for. The keyword here is `unless` though that I believe gates the response to only return the total if its sum is not part of the `combinations`.

This feels like cheating but I came really close from an understanding standpoint. My approach would've been far more difficult to work through. I also find it interesting that Elixir seems to have functions that work out exactly what these problems call for to a large degree but I suppose that comes from being able to break a problem down to composable functions. There are a number of other implementations [here](https://elixirforum.com/t/advent-of-code-2020-day-9/36087) or [here](https://github.com/rkachowski/advent-of-code/blob/master/2020/9/solution.exs) but I think this comes closest to what I was trying to achieve in syntax I'm fairly familiar with.

## Part 2
